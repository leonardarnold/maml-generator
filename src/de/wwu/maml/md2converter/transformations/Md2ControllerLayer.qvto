import Md2Helper;
import Md2ModelHelper;
import Md2ViewHelper;

modeltype MAML "strict" uses "http://de/wwu/md2dot0";
modeltype MD2 "strict" uses "http://www.wwu.de/md2/framework/MD2";

transformation Md2ControllerLayerTransformation(in Source: MAML, out Target: MD2);

main() {
	Source.rootObjects()[Model] -> map toControllerLayer();
}

mapping Model::toControllerLayer(): MD2Model {
	log("toControllerLayer");
	
	package := self.map toPackage();
	modelLayer := self.map toController();
}

mapping Model::toPackage(): PackageDefinition {
	log(".toPackage");
	pkgName := safeVal(self.projectName, DEFAULT_PROJECT_NAME).toFirstUpper() + ".controllers";
}

mapping Model::toController(): Controller {
	controllerElements := self.map toRemoteConnection();
	controllerElements += self.distinctContentProviders(); // also initializes data model
	controllerElements += self.distinctValidators();
	controllerElements += self.distinctWorkflowElements();
	controllerElements += self.distinctWebServiceCalls();
	controllerElements += self.map toMain();
}

helper Model::distinctContentProviders(): Collection(ContentProvider) {
	// initialize data model
	self.distinctModelElements();
	
	resolve(Entity)->forEach(entity) {
		entity.map toContentProvider();
	};
	
	return resolve(ContentProvider);
}

mapping MD2::Entity::toContentProvider(): ContentProvider {
	log(".toContentProvider: " + self.name);

	type := self.map toReferencedModelType(false);
	name := self.name.toFirstUpper() + "Provider";
	_default := false; // Not explicitly modelled in MAML
	local:= false; // TODO
	connection := resolveone(conn : RemoteConnection | conn.name = Source.rootObjects()[Model]->collectOne(model | model.getDefaultConnectionName()));
	filter := false; // Not explicitly modelled in MAML
	filterType := null; // Not explicitly modelled in MAML
	whereClause := null; // Not explicitly modelled in MAML
	_readonly := false; // Not explicitly modelled in MAML
}

helper Model::distinctValidators(): Set(Validator) {
	return Set{}; // TODO
}

mapping Model::toValidator(): Validator {
	// TODO
}

mapping Model::toMain(): Main {
	log(".toMain");
	
	appVersion := "1.0.0"; // Not explicitly modelled in MAML
	modelVersion := "1.0.0"; // Not explicitly modelled in MAML
	workflowManager := self.getRemoteConnection(self.getDefaultConnectionName()); // Not explicitly modelled in MAML
	defaultConnection := self.getRemoteConnection(self.getDefaultConnectionName()); // Not explicitly modelled in MAML
	fileUploadConnection := self.getRemoteConnection(self.getDefaultConnectionName()); // Not explicitly modelled in MAML
}

mapping Model::toRemoteConnection(): RemoteConnection {
	log(".toRemoteConnection");
	
	// Main remote connection, not explicitly modelled in MAML
	name := self.getDefaultConnectionName();
	uri := "http://localhost:8080/" + safeVal(self.projectName, DEFAULT_PROJECT_NAME).toFirstUpper() + ".backend/service/";
	password := null; 
	user := null;
	key := null;
	storagePath := null;
}

helper Model::distinctWebServiceCalls(): Set(WebServiceCall) {
	log(".distinctWebServiceCalls");

	var webServiceCalls: Set(WebServiceCall);
	
	self.useCases->forEach(uc) {
		uc.processFlowElements[Webservice]->oclAsType(Webservice)->forEach(ws){
			webServiceCalls += ws.lookupOrCreate();
		};
	};
	
	return webServiceCalls;
}

helper Webservice::lookupOrCreate(): WebServiceCall {
	if(resolveone(webservice : WebServiceCall | webservice.url = self.description) <> null) then {
		return resolveone(webservice : WebServiceCall | webservice.url = self.description);
	} else {
		return self.map toWebServiceCall();
	} endif;
}

mapping Webservice::toWebServiceCall(): WebServiceCall {
	name := "test"; // Not explicitly modelled in MAML // TODO generate unique Name
	url := self.description;
	method := RESTMethod::GET; // Not explicitly modelled in MAML
	queryparams := null; // Not explicitly modelled in MAML
	bodyparams := null; // TODO attached read attributes
}

helper Model::distinctWorkflowElements(): Collection(WorkflowElement) {
	log(".distinctWorkflowElements");
	
	// One MD2-WFE for each MAML-PFE
	self.useCases.processFlowElements->forEach(elem){
		elem.toWorkflowElement();
	};
	
	return resolve(WorkflowElement);
}

helper ProcessFlowElement::toWorkflowElement(): WorkflowElement {
	switch {
		case (self.oclIsKindOf(SelectEntity)) return self.oclAsType(SelectEntity).map toWorkflowElement();
		// TODO others
		// Skip Start/End Events and data sources
	};
	return null;
}

mapping SelectEntity::toWorkflowElement(): WorkflowElement {
	log("..toWorkflowElement: " + self.description);
	// TODO
	name := self.metaClassName().toFirstUpper().addSuffixNumber();
	initActions := self.map toInitAction(); //TODO
	actions := null; //TODO
	processChain := self.map toProcessChain(); //TODO
	invoke := null; //TODO
	defaultProcessChain := self.map toProcessChain(); //TODO	
}

mapping ProcessElement::toProcessChain(): ProcessChain {
	log("...toProcessChain");
	
	name := self.metaClassName().toFirstUpper() + "ProcessChain".addSuffixNumber();
	processChainSteps := self.map toProcessChainSteps(); // TODO
}

mapping ProcessElement::toProcessChainSteps(): ProcessChainStep {
	log("...toProcessChainSteps");
	
	name := self.metaClassName().toFirstUpper() + "ProcessChain".addSuffixNumber();
	view := self.lookupOrCreateProcessElement().map toReferencedType();// TODO
	gotos := null; // TODO
	message := null; // Not explicitly modelled in MAML
}

helper ProcessElement::lookupOrCreateProcessElement(): ViewElementType {
	return self.map toView(); // TODO
}

mapping MD2::ViewElementType::toReferencedType(): AbstractViewGUIElementRef {
	ref := self;
	tail := null; // TODO/necessary for MAML?
}

mapping ProcessElement::toInitAction(): Action {
	log("...toProcessChainSteps");
	
	name := "testAction"; // TODO
}