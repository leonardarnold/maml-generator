import Md2Helper;
import Md2ControllerHelper;

modeltype MAML "strict" uses "http://de/wwu/md2dot0";
modeltype MD2 "strict" uses "http://www.wwu.de/md2/framework/MD2";

transformation Md2WorkflowLayerTransformation(in Source: MAML, out Target: MD2);

main() {
	Source.rootObjects()[Model] -> map toWorkflowLayer();
}

mapping Model::toWorkflowLayer(): MD2Model {
	log("toWorkflowLayer");
	
	package := self.map toPackage();
	modelLayer := self.map toWorkflow();
}

mapping Model::toPackage(): PackageDefinition {
	log(".toPackage");
	
	pkgName := safeVal(self.projectName, DEFAULT_PROJECT_NAME).toFirstUpper() + ".workflows";
}

mapping Model::toWorkflow(): Workflow {
	workflowElementEntries := null;//TODO
	apps := null;//TODO
}

helper Model::toWorkflowElementEntries(): Collection(WorkflowElementEntry) {
	log(".toWorkflowElementEntries");
	
	var entries: Collection(WorkflowElementEntry) := Set {};
	
	self.distinctWorkflowElements(); // initialize controller layer
	self.useCases.processFlowElements->forEach(elem) {
		if(elem.oclIsTypeOf(ProcessElement) then {
			entries += elem.oclAsType(ProcessElement).map toWorkflowElementEntry();
		} endif;
	};
	
	return entries;
}

mapping ProcessElement::toWorkflowElementEntry(): WorkflowElementEntry {
	workflowElement := resolveone(elem : WorkflowElement | elem.name = self.description);
	invokable := self.isWorkflowElementInvokable();
	eventDesc := safeVal(self.container().oclAsType(UseCase).description, self.description, "");
	firedEvents := self.toFiredEvents();
}

query ProcessElement::isWorkflowElementInvokable(): Boolean {
	if(self.previousElements->size() = 1 and self.previousElements->first()->oclisTypeOf(StartEvent)) then { // allow XOR as first element??
		return true;
	} endif;
	return false;
}

helper ProcessElement::toFiredEvents(): Collection(FiredEventEntry) {
	// Fire event for each potentially following process element
	// TODO
}

query ProcessElement::getNextProcessElements(): Collection(ProcessElement) {
	if(self.nextElements->size() = 0) then {
		return Set {};
	} endif;
	
	var result : Collection(ProcessElement) := OrderedSet {};
	
	// TODO Error process flows?
	self.nextElements.targetElement->forEach(elem) {
		if(self.oclIsKindOf(ProcessElement)) then {
			result += elem;
		} else {
			// Else no real process element, e.g. end, xor, datasource -> get transitive follower
			result += elem.getNextProcessElements();
		};
	}

	return result;
}