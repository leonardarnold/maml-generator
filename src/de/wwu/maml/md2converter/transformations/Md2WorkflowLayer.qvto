import Md2Helper;
import Md2ControllerLayer;
import Md2ControllerHelper;
import Md2ControllerWfeHelper;

modeltype MAML "strict" uses "http://de/wwu/md2dot0";
modeltype MD2 "strict" uses "http://www.wwu.de/md2/framework/MD2";

transformation Md2WorkflowLayerTransformation(in Source: MAML, out Target: MD2);

main() {
	Source.rootObjects()[Model] -> map toWorkflowLayer();
}

mapping Model::toWorkflowLayer(): MD2Model {
	log("toWorkflowLayer");
	
	package := self.map toPackage();
	modelLayer := self.map toWorkflow();
}

mapping Model::toPackage(): PackageDefinition {
	log(".toPackage");
	
	pkgName := safeVal(self.projectName, DEFAULT_PROJECT_NAME).toFirstUpper() + ".workflows";
}

mapping Model::toWorkflow(): Workflow {
	workflowElementEntries := self.toWorkflowElementEntries();
	apps := self.getDistinctRoles()->map toApp();
}

helper Model::toWorkflowElementEntries(): Collection(WorkflowElementEntry) {
	var entries: Collection(WorkflowElementEntry) := Set {};
	
	self.map toController(); // initialize controller layer

	self.useCases.processFlowElements->forEach(elem) {
		if(elem.oclIsKindOf(ProcessElement) and not elem.oclIsKindOf(Transform)) then {
			entries += elem.oclAsType(ProcessElement).map toWorkflowElementEntry();
		} endif;
	};
	
	return entries;
}

mapping ProcessElement::toWorkflowElementEntry(): WorkflowElementEntry {
	log(".toWorkflowElementEntry: " + self.description);
	
	workflowElement := self.resolveone(elem : WorkflowElement);
	invokable := false;
	eventDesc := null; // Not explcitely modeled in MAML
	firedEvents := self.toFiredEvents();
}

helper ProcessElement::toFiredEvents(): Collection(FireEventEntry) {
	log("..toFiredEvents: " + self.getNextProcessElements()->size().toString() + " events");
	
	if(self.getNextProcessElements()->size() = 0) then {
		// No follower -> end process
		return Set { self.map toEndEvent() };
		
	} else {
		// Fire event for each potentially following process element
		return self.getNextProcessElements()->map toFiredEvent(self);
	} endif;
}

mapping ProcessElement::toFiredEvent(origin : ProcessElement): FireEventEntry {
	log("...toFiredEvent");
	
	event := origin.resolveone(WorkflowEvent);
	startedWorkflowElement := self.resolveone(WorkflowElement);
	endWorkflow := false;
}

mapping ProcessElement::toEndEvent(): FireEventEntry {
	log("...toEndEvent");
	
	event := self.resolveone(WorkflowEvent);
	endWorkflow := true;
}

mapping Role::toApp(): App {
	log(".toApp");
	
	name := safeVal(self.container().container().oclAsType(Model).projectName, DEFAULT_PROJECT_NAME).toFirstUpper() + "_" + safeVal(self.name);
	appName := safeVal(self.container().container().oclAsType(Model).projectName, DEFAULT_PROJECT_NAME).toFirstUpper() + " (" + safeVal(self.name) + ")";
	workflowElements := self.getWorkflowElements()->toWorkflowElementReference();
	defaultConnection := self.container().container().oclAsType(Model).getRemoteConnection();
}

helper MD2::WorkflowElement::toWorkflowElementReference(): WorkflowElementReference {
	return object WorkflowElementReference {
		workflowElementReference := self;
		startable := self.isStartable();
		if(self.isStartable()) then {
			alias := safeVal(self.getUseCase().title, self.name, "");
		} endif;
	}
}

//////////////////////////////////////////////////////////////////////
///////// Queries ////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

// Is the process element the first element within the process
query ProcessFlowElement::isWorkflowElementStartable(): Boolean { // TODO make transitive to skip first datasource etc.
	if(self.previousElements->size() != 1) then {
		return false;
	} elif (self.previousElements->first().sourceProcessFlowElement.oclIsTypeOf(ProcessStartEvent)) then { //TODO allow XOR as first element??
		return true;
	} elif (self.previousElements->first().sourceProcessFlowElement.oclIsKindOf(InteractionProcessElement)) then {
		// there is some visible screen before -> not startable
		return false;
	} else {
		return self.previousElements->first().sourceProcessFlowElement.isWorkflowElementStartable();
	} endif;
}

// Inverse to isWorkflowElementInvokable from MD2::WFE perspective
query MD2::WorkflowElement::isStartable(): Boolean {
	return self.invresolveone(ProcessElement).isWorkflowElementStartable();
}

// Get the following ProcessElement (i.e. find transitive followers through Events, XORs, ...)
query ProcessFlowElement::getNextProcessElements(): Collection(ProcessElement) {
	if(self.nextElements->size() = 0) then {
		return Set {};
	} endif;
	
	var collect : Collection(ProcessElement) := OrderedSet {};
	
	// TODO include Error process flows and special events
	self.nextElements.targetProcessFlowElement->forEach(elem) {
		if(elem.oclIsKindOf(Transform)) then {
			// Skip transform and get next real process element
			collect += elem.getNextProcessElements();
		} elif(elem.oclIsKindOf(ProcessElement)) then {
			collect += elem.oclAsType(ProcessElement);
		} else {
			// Else no real process element, e.g. end, xor, datasource -> get transitive followers
			collect += elem.getNextProcessElements();
		} endif;
	};
	return collect;
}

// Get a distinct set of roles across multiple use cases
query Model::getDistinctRoles(): Collection(Role) {
	return distinct(self.useCases.roles, self.useCases.roles.name)->oclAsType(Role);
}

// Get all WFE for a given role across multiple use cases
query Role::getWorkflowElements(): Collection(WorkflowElement) {
	var outcome : Collection(WorkflowElement) := Set{};
	
	self.container().container().oclAsType(Model).useCases.processFlowElements[ProcessElement]->forEach(elem){
		var wfe : WorkflowElement := elem.resolveone(WorkflowElement); 
		if(not (wfe = null)) then { // TODO check that role is assigned to this PE
			outcome += wfe;
		} endif;
	};
	return outcome;
}

// Retrieve inverse use case for WFE
query MD2::WorkflowElement::getUseCase(): MAML::UseCase {
	var pe : ProcessElement := self.invresolveone(ProcessElement);
	return pe.container().oclAsType(UseCase);
}