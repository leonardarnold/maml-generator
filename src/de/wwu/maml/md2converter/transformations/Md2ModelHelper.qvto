library Md2ModelHelper;

import Md2Helper;

modeltype MAML "strict" uses "http://de/wwu/md2dot0";
modeltype MAMLdata "strict" uses "http://de/wwu/md2dot0data";
modeltype MAMLgui "strict" uses "http://de/wwu/md2dot0gui";
modeltype MD2 "strict" uses "http://www.wwu.de/md2/framework/MD2";

helper Model::distinctModelElements(): Set(ModelElement) {
	log(".distinctModelElements");
	
	// Custom types
	self.useCases.dataTypes->forEach(dataType){
		dataType->oclAsType(DataType).lookupOrCreate();
	};

	return null;
}

helper DataType::lookupOrCreate(): ModelElement {
	if(resolveone(dataType : ModelElement | dataType.name = self.metaClassName().toFirstUpper()) <> null) then {
		return resolveone(dataType : ModelElement | dataType.name = self.metaClassName().toFirstUpper());
	} endif;
	return self.toModelElement();
}

helper DataType::toModelElement(): ModelElement {
	var element : ModelElement;
	
	switch {
		case (self.oclIsTypeOf(CustomType)) element := self.oclAsType(CustomType).map toEntity();
		case (self.oclIsTypeOf(Enum)) element := self.oclAsType(Enum).map toEnum();
		case (self.oclIsTypeOf(DataTypeLiteral) and not self.oclAsType(DataTypeLiteral)._primitive) element := self.oclAsType(DataTypeLiteral).map toEntity();
		else return null; // Skip data type literals
	};
	
	return element;
}

mapping CustomType::toEntity(): Entity when {self.attributes->size() > 0} {
	log("..toEntity: " + self.name.toFirstUpper());
	
	name := self.name.toFirstUpper();
	attributes := self.attributes->toPrimitiveOrComplexAttribute();
}

mapping DataTypeLiteral::toEntity(): Entity {
	log("..toEntity: " + self.name.toFirstUpper());
	
	name := self.name.toFirstUpper();
	attributes := null;
}

mapping DataType::toEnum(): MD2::Enum {
	log("..toEnum: " + self.metaClassName().toFirstUpper());
	//TODO enumBody
	name := self.metaClassName().toFirstUpper();
}

helper Property::toPrimitiveOrComplexAttribute(): MD2::Attribute {
	log("...toPrimitiveOrComplexAttributeType: Attribute " + self.name);
	
	return self.map toAttribute();
}

helper DataType::toPrimitiveOrComplexAttributeType(): MD2::AttributeType {
	return self.toPrimitiveOrComplexAttributeType(false);
}

helper DataType::toPrimitiveOrComplexAttributeType(isCollection : Boolean): MD2::AttributeType {
	switch {
		// Primitive conversion
		case (self.oclIsTypeOf(_Integer)) return self.oclAsType(_Integer).map toPrimitiveInt(isCollection);
		case (self.oclIsTypeOf(Float)) return self.oclAsType(Float).map toPrimitiveFloat(isCollection);
		case (self.oclIsTypeOf(_String)) return self.oclAsType(_String).map toPrimitiveString(isCollection);
		case (self.oclIsTypeOf(_Boolean)) return self.oclAsType(_Boolean).map toPrimitiveBoolean(isCollection);
		case (self.oclIsTypeOf(Date)) return self.oclAsType(Date).map toPrimitiveDate(isCollection);
		case (self.oclIsTypeOf(Time)) return self.oclAsType(Time).map toPrimitiveTime(isCollection);
		case (self.oclIsTypeOf(DateTime)) return self.oclAsType(DateTime).map toPrimitiveDateTime(isCollection);
		case (self.oclIsTypeOf(File)) return self.oclAsType(File).map toPrimitiveFile(isCollection);
		// MAML primitives to MD2 non-primitives
		case (self.oclIsTypeOf(PhoneNumber)) return self.oclAsType(PhoneNumber).map toPrimitiveString(isCollection);
		case (self.oclIsTypeOf(Url)) return self.oclAsType(Url).map toPrimitiveString(isCollection);
		case (self.oclIsTypeOf(Email)) return self.oclAsType(Email).map toPrimitiveString(isCollection);
		// Complex types
		case (self.oclIsTypeOf(CustomType)) return self.oclAsType(CustomType).toReferencedType(isCollection);
		case (self.oclIsTypeOf(_Collection)) return self.oclAsType(_Collection).type.toPrimitiveOrComplexAttributeType(true);
		case (self.oclIsTypeOf(Enum)) return self.oclAsType(Enum).toReferencedType(isCollection);
		else return null;
	};
}

mapping _Integer::toPrimitiveInt(isCollection : Boolean): IntegerType {
	log("....toPrimitiveInt");
	
	object result: IntegerType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Float::toPrimitiveFloat(isCollection : Boolean): FloatType {
	log("....toPrimitiveFloat");
	
	object result: FloatType {
			many := isCollection;
			// TODO params 
	} 
}

mapping _String::toPrimitiveString(isCollection : Boolean): StringType {
	log("....toPrimitiveString");
	
	object result: StringType {
			many := isCollection;
			// TODO params 
	} 
}

mapping PhoneNumber::toPrimitiveString(isCollection : Boolean): StringType {
	log("....toPrimitiveString");
	
	object result: StringType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Url::toPrimitiveString(isCollection : Boolean): StringType {
	log("....toPrimitiveString");
	
	object result: StringType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Email::toPrimitiveString(isCollection : Boolean): StringType {
	log("....toPrimitiveString");
	
	object result: StringType {
			many := isCollection;
			// TODO params 
	} 
}

mapping _Boolean::toPrimitiveBoolean(isCollection : Boolean): BooleanType {
	log("....toPrimitiveBoolean");
	
	object result: BooleanType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Date::toPrimitiveDate(isCollection : Boolean): DateType {
	log("....toPrimitiveDate");
	
	object result: DateType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Time::toPrimitiveTime(isCollection : Boolean): TimeType {
	log("....toPrimitiveTime");
	
	object result: TimeType {
			many := isCollection;
			// TODO params 
	} 
}

mapping DateTime::toPrimitiveDateTime(isCollection : Boolean): DateTimeType {
	log("....toPrimitiveDateTime");
	
	object result: DateTimeType {
			many := isCollection;
			// TODO params 
	} 
}

mapping File::toPrimitiveFile(isCollection : Boolean): FileType {
	log("....toPrimitiveFile");
	
	object result: FileType {
			many := isCollection;
			// TODO params 
	} 
}

helper DataType::toReferencedType(isCollection : Boolean): ReferencedType {
	// wrapper to find or create modelElement and reference it
	return self.lookupOrCreate().map toReferencedType(isCollection);
}

mapping MD2::ModelElement::toReferencedType(isCollection : Boolean): ReferencedType {
	element := self;
	many := isCollection;
	// TODO params
}


mapping MAMLdata::Property::toAttribute(): MD2::Attribute {
	log("...toAttribute: " + self.name.toFirstLower());
	
	name := self.name.toFirstLower();
	type := self.type.toPrimitiveOrComplexAttributeType();
	extendedName := null; // Not explicitly modelled in MAML
	description := null; // Not explicitly modelled in MAML
}

helper MD2::Entity::toReferencedModelType(isCollection : Boolean): ReferencedModelType {
	log("....toDataType");
	
	return object ReferencedModelType {
		many := isCollection;
		entity := self;
	}
}

helper DataTypeLiteral::toCustomType(): CustomType {
	return resolveone(type : CustomType | type.name.equalsIgnoreCase(self.identifier));
}

query MAMLgui::Attribute::getProperty(): Property {
	var rootModel : MAML::Model := self.container().container().oclAsType(Model);

	return rootModel.allSubobjectsOfKind(Property)->any(elem | elem.name = self.description and elem.type.metaClassName() = self.type);
}

query MAMLgui::Attribute::getAttribute(): MD2::Attribute {
	return self.getProperty().resolveone(MD2::Attribute);	
}

query ContentProvider::getPathToAttribute(attribute : MD2::Attribute): Sequence(MD2::Attribute) {
	var startEntity : Entity := self.type.oclAsType(ReferencedModelType).entity.oclAsType(Entity); // TODO traverse
	
	var outcome := startEntity._getRecursivePathToAttribute(attribute, Sequence{});
	return outcome;
}

query MD2::Entity::_getRecursivePathToAttribute(attribute : MD2::Attribute, steps: Sequence(MD2::Attribute)): Sequence(MD2::Attribute) {
	log("....recursivePath: From " + self.toString() + " to " + attribute.name);
	
	// Break after 4 steps of nesting
	if(steps->size() > 3) then {
		return Sequence{};
	} endif;
	
	self.attributes->forEach(nestedItem){
		if (nestedItem.name = attribute.name and nestedItem.type = attribute.type) then {
			// Found a match
			return steps->append(attribute);
		} elif(nestedItem.type.oclIsKindOf(Entity)) then {
			// Continue nesting
			return nestedItem.oclAsType(Entity)._getRecursivePathToAttribute(attribute, steps->append(nestedItem));
		} endif;
	};
	
	log ("ERROR:getRecursivePathToAttribute"); return null;
}