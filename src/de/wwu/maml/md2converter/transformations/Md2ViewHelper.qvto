library Md2ViewHelper;

import Md2Helper;
import Md2ControllerHelper;

modeltype MAML "strict" uses "http://de/wwu/md2dot0";
modeltype MAMLdata "strict" uses "http://de/wwu/md2dot0data";
modeltype MAMLgui "strict" uses "http://de/wwu/md2dot0gui";
modeltype MD2 "strict" uses "http://www.wwu.de/md2/framework/MD2";

helper Model::distinctViewElementTypes(): Collection(ViewElementType) {
	log(".distinctViewElements");
	
	// initialize controller layer
	self.distinctContentProviders();
	
	return self.useCases.processFlowElements[ProcessElement]->oclAsType(ProcessElement).lookupOrCreateViewElement();
}

helper ProcessElement::lookupOrCreateViewElement(): ViewElementType {
	if(resolveone(ve : ViewElementType | ve.name = self.metaClassName().toFirstUpper()) <> null) then {
		return resolveone(ve : ViewElementType | ve.name = self.metaClassName().toFirstUpper());
	} endif;
	return self.map toViewElement();
}

mapping ProcessElement::toViewElement(): FlowLayoutPane {
	log("..toViewElement: " + self.metaClassName() + "View");
	
	name := self.metaClassName() + "View".addSuffixNumber();
	params := getFlowDirectionParam(true);
	elements := self.toViewElementContent();
}

helper getFlowDirectionParam(vertical : Boolean): FlowLayoutPaneFlowDirectionParam {
	var direction : FlowDirection := FlowDirection::VERTICAL;
	if(not vertical) then {
		direction := FlowDirection::HORIZONTAL;
	} endif;
	
	return object FlowLayoutPaneFlowDirectionParam {
		flowDirection := direction;
	}
}

helper MD2::ViewElementType::toReferencedType(): AbstractViewGUIElementRef {
	return object AbstractViewGUIElementRef {
		ref := self;
		tail := null; // TODO/necessary for MAML?
	}
}

helper ProcessElement::toViewElementContent(): Collection(ViewGUIElement){
	// The real stuff happens in the subtype specific toViewElementContent methods
	log("ERROR: Unhandled process element type: " + self.metaClassName() + "(" + self.description + ")");
	return null;//self.getAttachedParameters()->toContentElement();
}

helper SelectEntity::toViewElementContent(): Collection(ViewGUIElement){
	var content : OrderedSet(ViewGUIElement) := OrderedSet { self.map toTitle() }; // Title 
	content += self.getAttachedLabels().map toLabel(); // Labels
	content += self->map toTable(self.getAttachedAttributes()); // Table (ideally)
	content += OrderedSet { createSpacer() }; // Spacer between content and button block
	content += self.toContinueButtons(); // Buttons
	return content;
}

helper ShowEntity::toViewElementContent(): Collection(ViewGUIElement){
	var content : OrderedSet(ViewGUIElement) := OrderedSet { self.map toTitle() }; // Title 
	content += self.getAttachedParameters().toViewElements(); // Fields
	content += OrderedSet { createSpacer() }; // Spacer between content and button block
	content += self.toContinueButtons(); // Buttons
	return content->flatten();
}

helper UpdateEntity::toViewElementContent(): Collection(ViewGUIElement){
	var content : OrderedSet(ViewGUIElement) := OrderedSet { self.map toTitle() }; // Title 
	content += self.getAttachedParameters().toViewElements(); // Fields
	content += OrderedSet { createSpacer() }; // Spacer between content and button block
	content += self.toContinueButtons(); // Buttons
	return content->flatten();
}

helper CreateEntity::toViewElementContent(): Collection(ViewGUIElement){
	var content : OrderedSet(ViewGUIElement) := OrderedSet { self.map toTitle() }; // Title 
	content += self.getAttachedParameters().toViewElements(); // Fields
	content += OrderedSet { createSpacer() }; // Spacer between content and button block
	content += self.toContinueButtons(); // Buttons
	return content->flatten();
}

helper ParameterConnector::toViewElements(): Collection(ViewGUIElement){
	log("...toViewElements");
	
	switch {
		case (self.targetElement.oclIsTypeOf(Label)) return OrderedSet { self.map toLabel() };
		case (self.targetElement.oclIsTypeOf(Attribute) and self.accessType = AccessType::READ) return OrderedSet { self.map toReadAttribute() };
		case (self.targetElement.oclIsTypeOf(Attribute) and self.accessType = AccessType::WRITE) return OrderedSet { self.targetElement.oclAsType(MAMLgui::Attribute).map toWriteAttribute() }->flatten();
		// TODO computed attributes...
	};
	
	return Set {};
}

mapping ProcessElement::toTitle(): MD2::Label {
	log("...toTitle");
	
	object result: MD2::Label {
		name := "_title" + self.description.toName();
		text := self.description;
		width := 100;
		style := null; // TODO heading style?
	}
} 

mapping ParameterConnector::toLabel(): MD2::Label {
	log("...toLabel");
	
	object result: MD2::Label {
		name := "label".addSuffixNumber();
		text := self.description;
		width := 100;
		style := null; // TODO label style?
	}
} 

helper createSpacer(): Spacer {
	return object Spacer {};
}

helper ProcessElement::toContinueButtons(): OrderedSet(MD2::Button){
	var buttons : OrderedSet(Button) := OrderedSet{};
	
	Sequence{1..self.getAmountOfContinueButtons()}->forEach(index) { 
		buttons += self.map toContinueButton(index);
	};
	
	return buttons;
}

mapping ProcessElement::toContinueButton(index : Integer): MD2::Button {
	log("...toContinueButton: " + self.getContinueButtonText(index));
	
	name := "buttonContinue".addSuffixNumber();
	text := self.getContinueButtonText(index);
	width := 100;
	style := null; // TODO button style?
} 

mapping ProcessElement::toTable(attributes : Collection(ParameterConnector)): MD2::EntitySelector {
	log("...toTable");
	
	name := "table".addSuffixNumber();
	textProposition := self.dataType.lookupOrCreate().oclAsType(MD2::Entity).toContentProviderPath(attributes->asOrderedSet()->first().targetElement.oclAsType(Attribute), true);
}

mapping ParameterConnector::toReadAttribute(): FlowLayoutPane {
	log("...toReadAttribute");
	
	name := "attributePane".addSuffixNumber();
	elements := OrderedSet { self.map toAttributeLabel() , self.map toReadAttributeField() };
	params := getFlowDirectionParam(false);
}

mapping ParameterConnector::toAttributeLabel(): MD2::Label {
	name := "attributeLabel".addSuffixNumber();
	text := self.description;
	width := 40;
	style := null; // TODO label style?
}

mapping ParameterConnector::toReadAttributeField(): MD2::Label {
	name := "attributeField".addSuffixNumber();
	text := safeVal(self.targetElement.description, "");
	width := 60;
	style := null; // TODO label style?
}

helper MAMLgui::Attribute::toWriteAttribute(): OrderedSet(ViewGUIElement) {
	var attribute := self;// MAMLgui::Attribute := self.targetElement.oclAsType(MAMLgui::Attribute); 
	
	switch {
		//TODO more
		// TODO currently as String -> bad!
		case (attribute.type.equalsIgnoreCase("String") or attribute.type.oclIsTypeOf(_String)) return OrderedSet { attribute.map toTextInput() };
		case (attribute.type.equalsIgnoreCase("Integer") or attribute.type.oclIsTypeOf(_Integer)) return OrderedSet { attribute.map toIntegerInput() };		
		case (attribute.type.equalsIgnoreCase("Float") or attribute.type.oclIsTypeOf(Float)) return OrderedSet { attribute.map toNumberInput() };
		case (attribute.type.equalsIgnoreCase("Boolean") or attribute.type.oclIsTypeOf(_Boolean)) return OrderedSet { attribute.map toBooleanInput() };
		case (attribute.type.equalsIgnoreCase("Date") or attribute.type.oclIsTypeOf(Date)) return OrderedSet { attribute.map toDateInput() };
		case (attribute.type.equalsIgnoreCase("Time") or attribute.type.oclIsTypeOf(Time)) return OrderedSet { attribute.map toTimeInput() };
		case (attribute.type.equalsIgnoreCase("DateTime") or attribute.type.oclIsTypeOf(DateTime)) return OrderedSet { attribute.map toDateTimeInput() };
		case (attribute.type.equalsIgnoreCase("File") or attribute.type.oclIsTypeOf(File)) return OrderedSet { attribute.map toFileInput() };
		// MAML primitives to MD2 non-primitives
		case (attribute.type.equalsIgnoreCase("PhoneNumber") or attribute.type.oclIsTypeOf(PhoneNumber)) return OrderedSet { attribute.map toTextInput() };
		case (attribute.type.equalsIgnoreCase("Url") or attribute.type.oclIsTypeOf(Url)) return OrderedSet { attribute.map toTextInput() };
		case (attribute.type.equalsIgnoreCase("Email") or attribute.type.oclIsTypeOf(Email)) return OrderedSet { attribute.map toTextInput() };
		// Complex types
	//	case (self.oclIsTypeOf(CustomType)) return self.oclAsType(CustomType).toReferencedType(isCollection); // TODO nested type
	//	case (self.oclIsTypeOf(_Collection)) return self.oclAsType(_Collection).type.toPrimitiveOrComplexAttributeType(true); // TODO multiple
		case (attribute.type.equalsIgnoreCase("Enum") or attribute.type.oclIsTypeOf(Enum)) return OrderedSet { attribute.map toOptionInput() };
		
		else return OrderedSet { attribute.map toTextInput() };
	};
	return OrderedSet{};
}

mapping MAMLgui::Attribute::toTextInput(): TextInput {
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	type := TextInputType::INPUT; //TODO textarea
	defaultValue := "";
} 

mapping MAMLgui::Attribute::toIntegerInput(): IntegerInput {
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	type := IntegerInputType::DEFAULT;
	defaultValue := 0;
}

mapping MAMLgui::Attribute::toNumberInput(): NumberInput {
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	type := NumberInputType::DEFAULT;
	defaultValue := 0;
}

mapping MAMLgui::Attribute::toBooleanInput(): BooleanInput {
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	type := BooleanInputType::DEFAULT;
	defaultValue := 'false';
}

mapping MAMLgui::Attribute::toDateInput(): DateInput {
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	type := DateInputType::DEFAULT;
	defaultValue := null;
}

mapping MAMLgui::Attribute::toTimeInput(): TimeInput {
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	type := TimeInputType::DEFAULT;
	defaultValue := null;
}

mapping MAMLgui::Attribute::toDateTimeInput(): DateTimeInput {
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	type := DateTimeInputType::DEFAULT;
	defaultValue := null;
}

mapping MAMLgui::Attribute::toOptionInput(): OptionInput {
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	type := OptionInputType::DEFAULT;
	defaultValue := null;
	enumReference := self.type.oclAsType(MAMLdata::Enum).resolveone(MD2::Enum);
}

mapping MAMLgui::Attribute::toFileInput(): FileUpload {
	log("..toFileInput");
	
	name := "writeAttribute".addSuffixNumber();
	width := 100;
	labelText := self.description;
	tooltipText := self.description; // TODO makes sense for Android?
	isDisabled := false;
	style := null; // TODO default style
	buttonValueText := self.description;
}

helper ProcessElement::getAttachedParameters(): Set(MAML::ParameterConnector) {
	var useCase: UseCase := self.container().oclAsType(UseCase);
	
	return useCase.processFlowConnections[ParameterConnector]
		->select(conn : ParameterConnector | conn.sourceElement = self)
		->sortedBy(conn : ParameterConnector | conn.order);
}

helper ProcessElement::getAttachedLabels(): Set(MAML::ParameterConnector) {
	return self.getAttachedParameters()
		->select(conn : ParameterConnector | conn.targetElement.oclIsTypeOf(MAMLgui::Label));
}

helper ProcessElement::getAttachedAttributes(): Set(MAML::ParameterConnector) {
	return self.getAttachedParameters()
		->select(conn : ParameterConnector | conn.targetElement.oclIsTypeOf(MAMLgui::Attribute));
}

helper ProcessElement::getAttachedAbstractAttributes(): Set(MAML::ParameterConnector) {
	return self.getAttachedParameters()
		->select(conn : ParameterConnector | conn.targetElement.oclIsKindOf(MAMLgui::AbstractAttribute));
}

helper ProcessElement::getContinueButtonText(atPosition : Integer): String {
	// TODO single/multi result events
	if(atPosition = 0 or self.getAmountOfContinueButtons() < atPosition) then {
		return null;
	} endif;
	
	if(self.getAmountOfContinueButtons() = 1) then {
		// Is last element?
		if(self.isFinishNext()) then {
			return safeVal(self.nextElements->first().description, DEFAULT_BUTTON_FINISH);
		} endif;
		
		// take directly following caption 
		return safeVal(self.nextElements->first().description, DEFAULT_BUTTON_TEXT);
	} else {
		// Search splitting point
		var searchXor := self.nextElements->first().targetProcessFlowElement;
		
		while(not searchXor.oclIsTypeOf(Xor)) {
			searchXor := searchXor.nextElements->first().targetProcessFlowElement;
		};
		// Select from multiple continues 
		return searchXor.nextElements->at(atPosition).description;
	} endif;
	return null; // Should never occur
}

//////////////////////////////////////////////////////////////////////
///////// Queries ////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

query ProcessFlowElement::getAmountOfContinueButtons(): Integer {
	// TODO single/multi result events
	if(self.nextElements->size() = 0) then {
		return -1;
	} elif(self.nextElements->size() > 1) then {
		// XOR check automatic or manual
		if(self.oclIsTypeOf(MAML::Xor) and self.parameters->size() = 0) then {
			return self.nextElements->size();
		} else {
			return 1; // Automatic Xor -> default continue
		} endif;
	} else {
		if(self.nextElements->first().targetProcessFlowElement.oclIsKindOf(ProcessElement)) then {
			return 1;
		} elif(self.nextElements->first().targetProcessFlowElement.oclIsTypeOf(ProcessEndEvent)) then {
			return 1;
		} else {
			return self.nextElements->first().targetProcessFlowElement.getAmountOfContinueButtons();
		} endif;
	} endif;
}

query ProcessFlowElement::isFinishNext(): Boolean {
	if(self.nextElements->size() = 0) then {
		return true; // Bug in model -> end
	} elif(self.nextElements->size() > 1) then {
		return false; // XOR
	} else {
		if(self.nextElements->first().targetProcessFlowElement.oclIsKindOf(ProcessEndEvent)) then {
			return true; // found an end
		} elif(self.nextElements->first().targetProcessFlowElement.oclIsKindOf(ProcessElement)) then {
			return false; 
		} else {
			return self.nextElements->first().targetProcessFlowElement.isFinishNext();
		} endif;
	} endif;
}