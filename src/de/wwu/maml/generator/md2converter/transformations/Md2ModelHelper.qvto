library Md2ModelHelper;

import Md2Helper;

modeltype MAML "strict" uses "http://de/wwu/maml/dsl/maml";
modeltype MAMLdata "strict" uses "http://de/wwu/maml/dsl/mamldata";
modeltype MAMLgui "strict" uses "http://de/wwu/maml/dsl/mamlgui";
modeltype MD2 "strict" uses "http://www.wwu.de/md2/framework/MD2";

helper Model::distinctModelElements(): Set(ModelElement) {
	log(".distinctModelElements");
	
	// Custom types
	self.useCases.dataTypes->forEach(dataType){
		dataType->oclAsType(DataType).lookupOrCreate();
	};

	return null;
}

helper DataType::lookupOrCreate(): ModelElement {
	if(resolveone(dataType : ModelElement | dataType.name = self.metaClassName().toFirstUpper()) <> null) then {
		return resolveone(dataType : ModelElement | dataType.name = self.metaClassName().toFirstUpper());
	} endif;
	return self.toModelElement();
}

helper DataType::toModelElement(): ModelElement {
	var element : ModelElement;
	
	switch {
		case (self.oclIsTypeOf(CustomType) and self.oclAsType(CustomType).isValidEntity()) element := self.oclAsType(CustomType).map toEntity();
		case (self.oclIsTypeOf(Enum)) element := self.oclAsType(Enum).map toEnum();
		case (self.oclIsTypeOf(DataTypeLiteral) and self.oclAsType(DataTypeLiteral).isValidEntity()) element := self.oclAsType(DataTypeLiteral).map toEntity();
		else return null; // Skip data type literals
	};
	
	return element;
}

helper DataType::isValidEntity(): Boolean {
	if(self.oclIsTypeOf(DataTypeLiteral) and self.oclAsType(DataTypeLiteral)._primitive) return false;
	
	var allDataTypes := self.container().container()->oclAsType(Model).useCases.dataTypes;
	if(self.oclIsTypeOf(DataTypeLiteral) and allDataTypes->exists(dt | dt.oclIsTypeOf(Enum) and dt.oclAsType(Enum).name = self.oclAsType(DataTypeLiteral).name)) return false;
	
	return true;
}

mapping CustomType::toEntity(): Entity when {self.attributes->size() > 0} {
	log("..toEntity: " + self.name.toFirstUpper());
	
	name := self.name.toFirstUpper();
	attributes := self.attributes->toPrimitiveOrComplexAttribute();
}

mapping DataTypeLiteral::toEntity(): Entity {
	log("..toEntity (from Literal): " + self.name.toFirstUpper());
	log(self.getChildAttributesOfType().toString()->join(","));
	log(self.getChildAttributesOfType().getAttribute().toString()->join(","));
	
	name := self.name.toFirstUpper();
	attributes := self.getChildAttributesOfType().getAttribute();
}

mapping Enum::toEnum(): MD2::Enum {
	log("..toEnum: " + self.name.toFirstUpper());
	
	name := self.name.toFirstUpper();
	enumBody := self.map toEnumBody();
}

mapping Enum::toEnumBody(): MD2::EnumBody {
	log("..toEnumBody: " + self.metaClassName().toFirstUpper());
	
	elements := self.values.value;
}

helper Property::toPrimitiveOrComplexAttribute(): MD2::Attribute {
	log("...toPrimitiveOrComplexAttributeType: Attribute " + self.name);
	
	return self.map toAttribute();
}

helper DataType::toPrimitiveOrComplexAttributeType(): MD2::AttributeType {
	return self.toPrimitiveOrComplexAttributeType(false);
}

helper DataType::toPrimitiveOrComplexAttributeType(isCollection : Boolean): MD2::AttributeType {
	//log("type:"+self.metaClassName());
	switch {
		// Primitive conversion
		case (self.oclIsTypeOf(_Integer)) return self.oclAsType(_Integer).map toPrimitiveInt(isCollection);
		case (self.oclIsTypeOf(Float)) return self.oclAsType(Float).map toPrimitiveFloat(isCollection);
		case (self.oclIsTypeOf(_String)) return self.oclAsType(_String).map toPrimitiveString(isCollection);
		case (self.oclIsTypeOf(_Boolean)) return self.oclAsType(_Boolean).map toPrimitiveBoolean(isCollection);
		case (self.oclIsTypeOf(Date)) return self.oclAsType(Date).map toPrimitiveDate(isCollection);
		case (self.oclIsTypeOf(Time)) return self.oclAsType(Time).map toPrimitiveTime(isCollection);
		case (self.oclIsTypeOf(DateTime)) return self.oclAsType(DateTime).map toPrimitiveDateTime(isCollection);
		case (self.oclIsTypeOf(File)) return self.oclAsType(File).map toPrimitiveFile(isCollection);
		// MAML primitives to MD2 non-primitives
		case (self.oclIsTypeOf(PhoneNumber)) return self.oclAsType(PhoneNumber).map toPrimitiveString(isCollection);
		case (self.oclIsTypeOf(Url)) return self.oclAsType(Url).map toPrimitiveString(isCollection);
		case (self.oclIsTypeOf(Email)) return self.oclAsType(Email).map toPrimitiveString(isCollection);
		// Complex types
		case (self.oclIsTypeOf(CustomType)) return self.oclAsType(CustomType).map toReferencedType(isCollection).clone();
		case (self.oclIsTypeOf(_Collection)) return self.oclAsType(_Collection).type.toPrimitiveOrComplexAttributeType(true);
		case (self.oclIsTypeOf(Enum)) return self.oclAsType(Enum).map toReferencedType(isCollection).clone();
		else return null;
	};
}

mapping _Integer::toPrimitiveInt(isCollection : Boolean): IntegerType {
	log("....toPrimitiveInt");
	
	object result: IntegerType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Float::toPrimitiveFloat(isCollection : Boolean): FloatType {
	log("....toPrimitiveFloat");
	
	object result: FloatType {
			many := isCollection;
			// TODO params 
	} 
}

mapping _String::toPrimitiveString(isCollection : Boolean): StringType {
	log("....toPrimitiveString");
	
	object result: StringType {
			many := isCollection;
			// TODO params 
	} 
}

mapping PhoneNumber::toPrimitiveString(isCollection : Boolean): StringType {
	log("....toPrimitiveString");
	
	object result: StringType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Url::toPrimitiveString(isCollection : Boolean): StringType {
	log("....toPrimitiveString");
	
	object result: StringType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Email::toPrimitiveString(isCollection : Boolean): StringType {
	log("....toPrimitiveString");
	
	object result: StringType {
			many := isCollection;
			// TODO params 
	} 
}

mapping _Boolean::toPrimitiveBoolean(isCollection : Boolean): BooleanType {
	log("....toPrimitiveBoolean");
	
	object result: BooleanType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Date::toPrimitiveDate(isCollection : Boolean): DateType {
	log("....toPrimitiveDate");
	
	object result: DateType {
			many := isCollection;
			// TODO params 
	} 
}

mapping Time::toPrimitiveTime(isCollection : Boolean): TimeType {
	log("....toPrimitiveTime");
	
	object result: TimeType {
			many := isCollection;
			// TODO params 
	} 
}

mapping DateTime::toPrimitiveDateTime(isCollection : Boolean): DateTimeType {
	log("....toPrimitiveDateTime");
	
	object result: DateTimeType {
			many := isCollection;
			// TODO params 
	} 
}

mapping File::toPrimitiveFile(isCollection : Boolean): FileType {
	log("....toPrimitiveFile");
	
	object result: FileType {
			many := isCollection;
			// TODO params 
	} 
}

mapping DataType::toReferencedType(isCollection : Boolean): ReferencedType {
	log("...toReferencedType");
	
	element := self.lookupOrCreate();
	many := isCollection;
	// TODO params
}

mapping MAMLdata::Property::toAttribute(): MD2::Attribute {
	log("...toAttribute1: " + self.name.toFirstLower());
	log(self.type.toPrimitiveOrComplexAttributeType().toString());
	name := self.name.toFirstLower();
	type := self.type.toPrimitiveOrComplexAttributeType();
	log(result.type.toString());
	extendedName := null; // Not explicitly modelled in MAML
	description := null; // Not explicitly modelled in MAML
}

mapping MAMLgui::Attribute::toAttribute(): MD2::Attribute {
	log("...toAttribute2: " + self.description.toFirstLower());
	
	name := self.type.toFirstLower();
	type := object DataTypeLiteral { name := self.type }.toPrimitiveOrComplexAttributeType();
	extendedName := null; // Not explicitly modelled in MAML
	description := null; // Not explicitly modelled in MAML
}

helper MD2::Entity::toReferencedModelType(isCollection : Boolean): ReferencedModelType {
	log("....toReferencedModelType");
	
	return object ReferencedModelType {
		many := isCollection;
		entity := self;
	}
}

helper DataTypeLiteral::toCustomType(): CustomType {
	return resolveone(type : CustomType | type.name.equalsIgnoreCase(self.identifier));
}

//////////////////////////////////////////////////////////////////////
///////// Queries ////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

// get data model property from GUI attribute
query MAMLgui::Attribute::getProperty(): Property {
	var rootModel : MAML::Model := self.container().container().oclAsType(Model);

	return rootModel.allSubobjectsOfKind(Property)->any(elem | elem.name = self.description and elem.type.metaClassName() = self.type);
}

// Get all MAML attributes with specified type
query MAMLdata::DataTypeLiteral::getChildAttributesOfType(): Set(MAMLgui::Attribute) {
	var rootModel : MAML::Model := self.container().container().oclAsType(Model);

	// TODO indirect children through computed attributes
	
	var attributeChildren : Set(MAMLgui::Attribute);
	attributeChildren := rootModel.allSubobjectsOfKind(MAMLgui::Attribute)->select(elem | elem.type = self.name).parameters.targetElement[MAMLgui::Attribute]->asSet();
	
	var processFlowChildren : Set(MAMLgui::Attribute);
	processFlowChildren := rootModel.allSubobjectsOfKind(MAML::ProcessFlowElement)->select(elem | elem.dataType.oclIsTypeOf(DataTypeLiteral) and elem.dataType.oclAsType(DataTypeLiteral).name = self.name).parameters.targetElement[MAMLgui::Attribute]->asSet();
	
	return attributeChildren->union(processFlowChildren);
}

// Resolve MD2 attribute from MAML GUI attribute
query MAMLgui::Attribute::getAttribute(): MD2::Attribute {
	return self.getProperty().resolveone(MD2::Attribute);	
}

// Find the path from a content provider to a GUI attribute
query  MD2::Entity::getPathToAttribute(attribute : MD2::Attribute): Sequence(MD2::Attribute) {
	var outcome := self._getRecursivePathToAttribute(attribute, Sequence{});
	return outcome;
}

query MD2::Entity::_getRecursivePathToAttribute(attribute : MD2::Attribute, steps: Sequence(MD2::Attribute)): Sequence(MD2::Attribute) {
	log("....recursivePath: " + self.name + " -> " + attribute.name);
	
	// Break after 4 steps of nesting
	if(steps->size() > 3) then {
		return Sequence{};
	} endif;
	
	self.attributes->forEach(nestedItem){
		if (nestedItem.name = attribute.name and nestedItem.type = attribute.type) then {
			// Found a match
			return steps->append(attribute);
		} elif(nestedItem.type.oclIsKindOf(Entity)) then {
			// Continue nesting
			return nestedItem.oclAsType(Entity)._getRecursivePathToAttribute(attribute, steps->append(nestedItem));
		} endif;
	};
	
	log ("ERROR:getRecursivePathToAttribute"); return null;
}